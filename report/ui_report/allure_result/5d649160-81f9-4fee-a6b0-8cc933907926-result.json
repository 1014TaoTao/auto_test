{"name": "test_01", "status": "broken", "statusDetails": {"message": "NameError: 没有找到 Chrome 浏览器,请确认 'ie','firefox','chrome','RChrome','RIe' or 'RFirefox'是否存在或名称是否正确.", "trace": "self = <selenium.webdriver.chrome.service.Service object at 0x0000021046629DF0>\n\n    def start(self):\n        \"\"\"\n        Starts the Service.\n    \n        :Exceptions:\n         - WebDriverException : Raised either when it can't start the service\n           or when it can't connect to the service\n        \"\"\"\n        try:\n            cmd = [self.path]\n            cmd.extend(self.command_line_args())\n>           self.process = subprocess.Popen(cmd, env=self.env,\n                                            close_fds=system() != 'Windows',\n                                            stdout=self.log_file,\n                                            stderr=self.log_file,\n                                            stdin=PIPE,\n                                            creationflags=self.creationflags)\n\nvenv\\lib\\site-packages\\selenium\\webdriver\\common\\service.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <subprocess.Popen object at 0x00000210466B3160>\nargs = ['chromedriver', '--port=65271'], bufsize = -1, executable = None\nstdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False\nshell = False, cwd = None\nenv = environ({'ALLUSERSPROFILE': 'C:\\\\ProgramData', 'APPDATA': 'C:\\\\Users\\\\tao\\\\AppData\\\\Roaming', 'CLASSPATH': 'D:\\\\JAVA\\\\...bin;;', '_OLD_VIRTUAL_PROMPT': '$P$G', 'PYTEST_CURRENT_TEST': 'testCase/ui/test_baidu.py::TestBaiDu::test_01 (setup)'})\nuniversal_newlines = None, startupinfo = None, creationflags = 0\nrestore_signals = True, start_new_session = False, pass_fds = ()\n\n    def __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n                 shell=False, cwd=None, env=None, universal_newlines=None,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=(), *, encoding=None, errors=None, text=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        _cleanup()\n        # Held while anything is calling waitpid before returncode has been\n        # updated to prevent clobbering returncode if wait() or poll() are\n        # called from multiple threads at once.  After acquiring the lock,\n        # code must re-check self.returncode to see if another thread just\n        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n    \n        self._input = None\n        self._communication_started = False\n        if bufsize is None:\n            bufsize = -1  # Restore default\n        if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize must be an integer\")\n    \n        if _mswindows:\n            if preexec_fn is not None:\n                raise ValueError(\"preexec_fn is not supported on Windows \"\n                                 \"platforms\")\n        else:\n            # POSIX\n            if pass_fds and not close_fds:\n                warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n                close_fds = True\n            if startupinfo is not None:\n                raise ValueError(\"startupinfo is only supported on Windows \"\n                                 \"platforms\")\n            if creationflags != 0:\n                raise ValueError(\"creationflags is only supported on Windows \"\n                                 \"platforms\")\n    \n        self.args = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr = None\n        self.pid = None\n        self.returncode = None\n        self.encoding = encoding\n        self.errors = errors\n    \n        # Validate the combinations of text and universal_newlines\n        if (text is not None and universal_newlines is not None\n            and bool(universal_newlines) != bool(text)):\n            raise SubprocessError('Cannot disambiguate when both text '\n                                  'and universal_newlines are supplied but '\n                                  'different. Pass one or the other.')\n    \n        # Input and output objects. The general principle is like\n        # this:\n        #\n        # Parent                   Child\n        # ------                   -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n        #\n        # On POSIX, the child objects are file descriptors.  On\n        # Windows, these are Windows file handles.  The parent objects\n        # are file descriptors on both platforms.  The parent objects\n        # are -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n    \n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread, errwrite) = self._get_handles(stdin, stdout, stderr)\n    \n        # We wrap OS handles *before* launching the child, otherwise a\n        # quickly terminating child could make our fds unwrappable\n        # (see #8458).\n    \n        if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(), 0)\n    \n        self.text_mode = encoding or errors or text or universal_newlines\n    \n        # How long to resume waiting on a child after the first ^C.\n        # There is no right value for this.  The purpose is to be polite\n        # yet remain good for interactive users trying to exit a tool.\n        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n    \n        self._closed_child_pipe_fds = False\n    \n        if self.text_mode:\n            if bufsize == 1:\n                line_buffering = True\n                # Use the default buffer size for the underlying binary streams\n                # since they don't support line buffering.\n                bufsize = -1\n            else:\n                line_buffering = False\n    \n        try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite, 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,\n                            line_buffering=line_buffering,\n                            encoding=encoding, errors=errors)\n            if c2pread != -1:\n                self.stdout = io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stdout = io.TextIOWrapper(self.stdout,\n                            encoding=encoding, errors=errors)\n            if errread != -1:\n                self.stderr = io.open(errread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n                            encoding=encoding, errors=errors)\n    \n>           self._execute_child(args, executable, preexec_fn, close_fds,\n                                pass_fds, cwd, env,\n                                startupinfo, creationflags, shell,\n                                p2cread, p2cwrite,\n                                c2pread, c2pwrite,\n                                errread, errwrite,\n                                restore_signals, start_new_session)\n\nD:\\python\\lib\\subprocess.py:858: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <subprocess.Popen object at 0x00000210466B3160>\nargs = 'chromedriver --port=65271', executable = None, preexec_fn = None\nclose_fds = False, pass_fds = (), cwd = None\nenv = environ({'ALLUSERSPROFILE': 'C:\\\\ProgramData', 'APPDATA': 'C:\\\\Users\\\\tao\\\\AppData\\\\Roaming', 'CLASSPATH': 'D:\\\\JAVA\\\\...bin;;', '_OLD_VIRTUAL_PROMPT': '$P$G', 'PYTEST_CURRENT_TEST': 'testCase/ui/test_baidu.py::TestBaiDu::test_01 (setup)'})\nstartupinfo = <subprocess.STARTUPINFO object at 0x00000210466B31F0>\ncreationflags = 0, shell = False, p2cread = Handle(308), p2cwrite = 7\nc2pread = -1, c2pwrite = Handle(384), errread = -1, errwrite = Handle(772)\nunused_restore_signals = True, unused_start_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       unused_restore_signals, unused_start_new_session):\n        \"\"\"Execute program (MS Windows version)\"\"\"\n    \n        assert not pass_fds, \"pass_fds not supported on Windows.\"\n    \n        if isinstance(args, str):\n            pass\n        elif isinstance(args, bytes):\n            if shell:\n                raise TypeError('bytes args is not allowed on Windows')\n            args = list2cmdline([args])\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = list2cmdline([args])\n        else:\n            args = list2cmdline(args)\n    \n        if executable is not None:\n            executable = os.fsdecode(executable)\n    \n        # Process startup details\n        if startupinfo is None:\n            startupinfo = STARTUPINFO()\n        else:\n            # bpo-34044: Copy STARTUPINFO since it is modified above,\n            # so the caller can reuse it multiple times.\n            startupinfo = startupinfo.copy()\n    \n        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)\n        if use_std_handles:\n            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n            startupinfo.hStdInput = p2cread\n            startupinfo.hStdOutput = c2pwrite\n            startupinfo.hStdError = errwrite\n    \n        attribute_list = startupinfo.lpAttributeList\n        have_handle_list = bool(attribute_list and\n                                \"handle_list\" in attribute_list and\n                                attribute_list[\"handle_list\"])\n    \n        # If we were given an handle_list or need to create one\n        if have_handle_list or (use_std_handles and close_fds):\n            if attribute_list is None:\n                attribute_list = startupinfo.lpAttributeList = {}\n            handle_list = attribute_list[\"handle_list\"] = \\\n                list(attribute_list.get(\"handle_list\", []))\n    \n            if use_std_handles:\n                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]\n    \n            handle_list[:] = self._filter_handle_list(handle_list)\n    \n            if handle_list:\n                if not close_fds:\n                    warnings.warn(\"startupinfo.lpAttributeList['handle_list'] \"\n                                  \"overriding close_fds\", RuntimeWarning)\n    \n                # When using the handle_list we always request to inherit\n                # handles but the only handles that will be inherited are\n                # the ones in the handle_list\n                close_fds = False\n    \n        if shell:\n            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n            startupinfo.wShowWindow = _winapi.SW_HIDE\n            comspec = os.environ.get(\"COMSPEC\", \"cmd.exe\")\n            args = '{} /c \"{}\"'.format (comspec, args)\n    \n        if cwd is not None:\n            cwd = os.fsdecode(cwd)\n    \n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n    \n        # Start the process\n        try:\n>           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n                                     # no special security\n                                     None, None,\n                                     int(not close_fds),\n                                     creationflags,\n                                     env,\n                                     cwd,\n                                     startupinfo)\nE                                    FileNotFoundError: [WinError 2] 系统找不到指定的文件。\n\nD:\\python\\lib\\subprocess.py:1311: FileNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nbrowser = 'Chrome', remote_address = None\n\n    def select_browser(browser=setting.BROWSER, remote_address=None):\n        driver = None\n        start_time = time.time()\n        dc = {'platform': 'ANY', 'browserName': 'chrome', 'version': '', 'javascriptEnabled': True}\n        try:\n            if remote_address is None:  # web端\n                if browser == \"chrome\" or browser == \"Chrome\":\n                    # driver = webdriver.Chrome(service=Service(setting.DRIVER))\n                    options = webdriver.ChromeOptions()\n                    # options.add_argument('start-maximized')\n                    # 无头模式：启动浏览器进程，但不会显示出来\n                    # options.add_argument('--headless')\n                    # options.add_argument('--disable-gpu')\n                    # 新版本的去掉警告（70以上版本）\n                    options.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告\n                    options.add_experimental_option('excludeSwitches', ['enable-automation'])  # 去掉黄条\n>                   driver = webdriver.Chrome(chrome_options=options)\n\nbasepage\\browser.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <[AttributeError(\"'WebDriver' object has no attribute 'session_id'\") raised in repr()] WebDriver object at 0x21046602550>\nexecutable_path = 'chromedriver', port = 0\noptions = <selenium.webdriver.chrome.options.Options object at 0x00000210466025E0>\nservice_args = None, desired_capabilities = None, service_log_path = None\nchrome_options = <selenium.webdriver.chrome.options.Options object at 0x00000210466025E0>\nservice = <selenium.webdriver.chrome.service.Service object at 0x0000021046629DF0>\nkeep_alive = True\n\n    def __init__(self, executable_path=DEFAULT_EXECUTEABLE_PATH, port=DEFAULT_PORT,\n                 options: Options = None, service_args=None,\n                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,\n                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):\n        \"\"\"\n        Creates a new instance of the chrome driver.\n        Starts the service and then creates new instance of chrome driver.\n    \n        :Args:\n         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH\n         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.\n         - options - this takes an instance of ChromeOptions\n         - service - Service object for handling the browser driver if you need to pass extra details\n         - service_args - Deprecated: List of args to pass to the driver service\n         - desired_capabilities - Deprecated: Dictionary object with non-browser specific\n           capabilities only, such as \"proxy\" or \"loggingPref\".\n         - service_log_path - Deprecated: Where to log information from the driver.\n         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.\n        \"\"\"\n        if executable_path != 'chromedriver':\n            warnings.warn('executable_path has been deprecated, please pass in a Service object',\n                          DeprecationWarning, stacklevel=2)\n        if chrome_options:\n            warnings.warn('use options instead of chrome_options',\n                          DeprecationWarning, stacklevel=2)\n            options = chrome_options\n        if keep_alive != DEFAULT_KEEP_ALIVE:\n            warnings.warn('keep_alive has been deprecated, please pass in a Service object',\n                          DeprecationWarning, stacklevel=2)\n        else:\n            keep_alive = True\n        if not service:\n            service = Service(executable_path, port, service_args, service_log_path)\n    \n>       super(WebDriver, self).__init__(DesiredCapabilities.CHROME['browserName'], \"goog\",\n                                        port, options,\n                                        service_args, desired_capabilities,\n                                        service_log_path, service, keep_alive)\n\nvenv\\lib\\site-packages\\selenium\\webdriver\\chrome\\webdriver.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <[AttributeError(\"'WebDriver' object has no attribute 'session_id'\") raised in repr()] WebDriver object at 0x21046602550>\nbrowser_name = 'chrome', vendor_prefix = 'goog', port = 0\noptions = <selenium.webdriver.chrome.options.Options object at 0x00000210466025E0>\nservice_args = None, desired_capabilities = None, service_log_path = None\nservice = <selenium.webdriver.chrome.service.Service object at 0x0000021046629DF0>\nkeep_alive = True\n\n    def __init__(self, browser_name, vendor_prefix,\n                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,\n                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,\n                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):\n        \"\"\"\n        Creates a new WebDriver instance of the ChromiumDriver.\n        Starts the service and then creates new WebDriver instance of ChromiumDriver.\n    \n        :Args:\n         - browser_name - Browser name used when matching capabilities.\n         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.\n         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.\n         - options - this takes an instance of ChromiumOptions\n         - service_args - Deprecated: List of args to pass to the driver service\n         - desired_capabilities - Deprecated: Dictionary object with non-browser specific\n           capabilities only, such as \"proxy\" or \"loggingPref\".\n         - service_log_path - Deprecated: Where to log information from the driver.\n         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.\n        \"\"\"\n        if desired_capabilities:\n            warnings.warn('desired_capabilities has been deprecated, please pass in a Service object',\n                          DeprecationWarning, stacklevel=2)\n        if port != DEFAULT_PORT:\n            warnings.warn('port has been deprecated, please pass in a Service object',\n                          DeprecationWarning, stacklevel=2)\n        self.port = port\n        if service_log_path != DEFAULT_SERVICE_LOG_PATH:\n            warnings.warn('service_log_path has been deprecated, please pass in a Service object',\n                          DeprecationWarning, stacklevel=2)\n        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:\n            warnings.warn('keep_alive has been deprecated, please pass in a Service object',\n                          DeprecationWarning, stacklevel=2)\n        else:\n            keep_alive = True\n    \n        self.vendor_prefix = vendor_prefix\n    \n        _ignore_proxy = None\n        if not options:\n            options = self.create_options()\n    \n        if desired_capabilities:\n            for key, value in desired_capabilities.items():\n                options.set_capability(key, value)\n    \n        if options._ignore_local_proxy:\n            _ignore_proxy = options._ignore_local_proxy\n    \n        if not service:\n            raise AttributeError('service cannot be None')\n    \n        self.service = service\n>       self.service.start()\n\nvenv\\lib\\site-packages\\selenium\\webdriver\\chromium\\webdriver.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.chrome.service.Service object at 0x0000021046629DF0>\n\n    def start(self):\n        \"\"\"\n        Starts the Service.\n    \n        :Exceptions:\n         - WebDriverException : Raised either when it can't start the service\n           or when it can't connect to the service\n        \"\"\"\n        try:\n            cmd = [self.path]\n            cmd.extend(self.command_line_args())\n            self.process = subprocess.Popen(cmd, env=self.env,\n                                            close_fds=system() != 'Windows',\n                                            stdout=self.log_file,\n                                            stderr=self.log_file,\n                                            stdin=PIPE,\n                                            creationflags=self.creationflags)\n        except TypeError:\n            raise\n        except OSError as err:\n            if err.errno == errno.ENOENT:\n>               raise WebDriverException(\n                    \"'%s' executable needs to be in PATH. %s\" % (\n                        os.path.basename(self.path), self.start_error_message)\nE                       selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://chromedriver.chromium.org/home\n\nvenv\\lib\\site-packages\\selenium\\webdriver\\common\\service.py:81: WebDriverException\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture(scope=\"session\", autouse=True)\n    def init_project():\n        global driver\n        with allure.step(\"打开浏览器并最大化\"):\n            if driver is None:\n>               driver = select_browser()\n\ntestCase\\ui\\conftest.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nbrowser = 'Chrome', remote_address = None\n\n    def select_browser(browser=setting.BROWSER, remote_address=None):\n        driver = None\n        start_time = time.time()\n        dc = {'platform': 'ANY', 'browserName': 'chrome', 'version': '', 'javascriptEnabled': True}\n        try:\n            if remote_address is None:  # web端\n                if browser == \"chrome\" or browser == \"Chrome\":\n                    # driver = webdriver.Chrome(service=Service(setting.DRIVER))\n                    options = webdriver.ChromeOptions()\n                    # options.add_argument('start-maximized')\n                    # 无头模式：启动浏览器进程，但不会显示出来\n                    # options.add_argument('--headless')\n                    # options.add_argument('--disable-gpu')\n                    # 新版本的去掉警告（70以上版本）\n                    options.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告\n                    options.add_experimental_option('excludeSwitches', ['enable-automation'])  # 去掉黄条\n                    driver = webdriver.Chrome(chrome_options=options)\n    \n                elif browser == \"firefox\" or browser == \"Firefox\":\n                    driver = webdriver.Firefox()\n                elif browser == \"internet explorer\" or browser == \"ie\":\n                    driver = webdriver.Ie()\n                elif browser == \"opera\":\n                    driver = webdriver.Opera()\n                elif browser == \"edge\":\n                    driver = webdriver.Edge()\n            else:  # 移动端\n                if browser == \"RChrome\":\n                    driver = webdriver.Remote(command_executor='https://' + remote_address + '/wd/hub',\n                                              desired_capabilities=dc)\n                elif browser == \"RIE\":\n                    dc['browserName'] = 'internet explorer'\n                    driver = webdriver.Remote(command_executor='https://' + remote_address + '/wd/hub',\n                                              desired_capabilities=dc)\n                elif browser == \"RFirefox\":\n                    dc['browserName'] = 'firefox'\n                    dc['marionette'] = False\n                    driver = webdriver.Remote(command_executor='https://' + remote_address + '/wd/hub',\n                                              desired_capabilities=dc)\n            logger.info(\n                \"{0}==> 开启浏览器: {1}, 共花费 {2} 秒\".format(success, browser, \"%.4f\" % (time.time() - start_time)))\n    \n        except Exception:\n>           raise NameError(\"没有找到 {0} 浏览器,请确认 'ie','firefox',\"\n                            \"'chrome','RChrome','RIe' or 'RFirefox'是否存在或名称是否正确.\".format(browser))\nE           NameError: 没有找到 Chrome 浏览器,请确认 'ie','firefox','chrome','RChrome','RIe' or 'RFirefox'是否存在或名称是否正确.\n\nbasepage\\browser.py:61: NameError"}, "description": "test_01", "start": 1657704431618, "stop": 1657704431618, "uuid": "36cc2456-845b-4d97-998f-ac18bc5805fa", "historyId": "cafdc1e2b84c36682f7492c461018890", "testCaseId": "e07d91e67aaa570b8651213e3652ad2b", "fullName": "testCase.ui.test_baidu.TestBaiDu#test_01", "labels": [{"name": "epic", "value": "test_01"}, {"name": "feature", "value": "feature一级标签:百度测试用例"}, {"name": "severity", "value": "blocker"}, {"name": "story", "value": "story二级标签:test_01"}, {"name": "tag", "value": "@pytest.mark.usefixtures('init_project')"}, {"name": "parentSuite", "value": "testCase.ui"}, {"name": "suite", "value": "test_baidu"}, {"name": "subSuite", "value": "TestBaiDu"}, {"name": "host", "value": "ZhangTao"}, {"name": "thread", "value": "13388-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "testCase.ui.test_baidu"}], "links": [{"type": "test_case", "url": "https://www.baidu.com/", "name": "allure.testcase：测试用例地址"}, {"type": "issue", "url": "https://www.baidu.com/", "name": "allure.issue：BUG地址"}, {"type": "link", "url": "https://www.baidu.com/", "name": "allure.link：超链接"}]}